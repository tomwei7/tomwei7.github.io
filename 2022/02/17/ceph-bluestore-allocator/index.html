<!doctype html><html lang=zh-cn><head><title>Ceph BlueStore 实现 - Allocator // 围城</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.85.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="围城"><meta name=description content><link rel=stylesheet href=https://tomwei7.com/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-72226462-1','auto'),ga('send','pageview'))</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Ceph BlueStore 实现 - Allocator"><meta name=twitter:description content="背景 BlueStore 是 ceph 的新一代高性能 OSD 存储引擎用于取代以前的 FileStore。BlueStore 不像 FileStore 那样需要依赖文件系统而且选择绕过文件系统直接操作"><meta property="og:title" content="Ceph BlueStore 实现 - Allocator"><meta property="og:description" content="背景 BlueStore 是 ceph 的新一代高性能 OSD 存储引擎用于取代以前的 FileStore。BlueStore 不像 FileStore 那样需要依赖文件系统而且选择绕过文件系统直接操作"><meta property="og:type" content="article"><meta property="og:url" content="https://tomwei7.com/2022/02/17/ceph-bluestore-allocator/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-17T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-17T00:00:00+00:00"></head><body><header class=app-header><a href=https://tomwei7.com><img class=app-header-avatar src=/avatar.png alt=围城></a>
<a href=https://tomwei7.com><h1>围城</h1></a><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>程序员-代码-吐槽</p></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Ceph BlueStore 实现 - Allocator</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Feb 17, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://tomwei7.com/tags/ceph/>ceph</a>
<a class=tag href=https://tomwei7.com/tags/bluestore/>bluestore</a></div></div></header><div class=post-content><h3 id=背景>背景</h3><p>BlueStore 是 ceph 的新一代高性能 OSD 存储引擎用于取代以前的 FileStore。BlueStore 不像 FileStore 那样需要依赖文件系统而且选择绕过文件系统直接操作裸的块设备，可以对底层存储设备拥有更加精细的控制同时去掉了需要把对 RADOS 层的操作转换为 POSIX 语义的文件操作的过程也大大提高了性能。BlueStore 在设计时充分考虑了未来 SSD 的普及，而不在拘泥于 HDD。基于这样的考虑 BlueStore 在设计时可以一部分摒弃已有文件系统为了适配 HDD 而做的妥协（HDD随机读写速度远低于顺序读写，随机读写IOPS约120等），可以重复利用未来 SSD 的优势。</p><p>BlueStore 选择绕过了文件系统选择直接操作裸设备，那么 BlueStore 就必须要自己实现自己的 Allocator 来做空间的分配。由于 BlueStore 的设计目标是适配 SSD 考虑到与传统磁盘相比，SSD 普通普通采用 4K 或者更大的块大小，因此 SSD 采用位图进行空间管理可以取的比较高的空间收益，假设 SSD 块大小为 4K，如果磁盘容量为 1T 那么使用位图管理磁盘空间，那么需要的内存是 32MB，完全可以实现常驻内存，所以 BlueStore 的 Allocator 选择回归传统，使用位图的方式管理磁盘空间。</p><blockquote><blockquote><p>💡 但是目前 HDD 相较于 SSD 仍然有很大的价格优势，目前最大 HDD 硬盘可以到 20T 以后 SMR 的硬盘可能更大，如果使用 45drives 的 60 盘位的存储型服务器，然后使用 BlueStore 如果使用 4K 的块大小将需要消耗 37.5G 内存如果 512 块大小需要消耗 296G 内存</p></blockquote></blockquote><h3 id=bluestore-allocator-接口定义>BlueStore Allocator 接口定义</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Allocator</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
  <span style=color:#75715e>/*
</span><span style=color:#75715e>   * Allocate required number of blocks in n number of extents.
</span><span style=color:#75715e>   * Min and Max number of extents are limited by:
</span><span style=color:#75715e>   * a. alloc unit
</span><span style=color:#75715e>   * b. max_alloc_size.
</span><span style=color:#75715e>   * as no extent can be lesser than block_size and greater than max_alloc size.
</span><span style=color:#75715e>   * Apart from that extents can vary between these lower and higher limits according
</span><span style=color:#75715e>   * to free block search algorithm and availability of contiguous space.
</span><span style=color:#75715e>   */</span>
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int64_t</span> allocate(<span style=color:#66d9ef>uint64_t</span> want_size, <span style=color:#66d9ef>uint64_t</span> block_size,
                           <span style=color:#66d9ef>uint64_t</span> max_alloc_size, <span style=color:#66d9ef>int64_t</span> hint,
                           PExtentVector <span style=color:#f92672>*</span>extents) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

  <span style=color:#75715e>/* Bulk release. Implementations may override this method to handle the whole
</span><span style=color:#75715e>   * set at once. This could save e.g. unnecessary mutex dance. */</span>
  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>release</span>(<span style=color:#66d9ef>const</span> interval_set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;&amp;</span> release_set) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};
</code></pre></div><p>BlueStore 的 Allocator 接口定义十分的简洁，去除辅助相关接口定义后，只剩下 <code>allocate</code> 与 <code>release</code></p><ul><li>allocate 用于从 Allocator 分配空间，由于空间碎片问题 allocate 可能会返回多个 extent, 没有 extent 包含 offset 与 length</li><li>release 用于是否已分配的空间，release的参数看起来有点奇怪 interval_set 实际的数据为N对 offset,length 及 interval_set = &#171;offset,length>,&lt;offset,length>&mldr;></li></ul><h3 id=bluestore-位图-allocator>BlueStore 位图 Allocator</h3><p>在探究 BlueStore 如果使用位图实现 Allocator 之前，首先让我们看下位图管理磁盘空间的基本原理。因为对磁盘的读写操作都是有着最小的操作单位称之为 Block Size，在 HDD 时代一般是磁盘扇区大小为 512B，后期的 HDD 和现代的 SDD 大多使用 4K 作为最 Block Size，但是大多也兼容 512B 但是会导致性能下降也就是之前大家常说的 4K 对齐。以现在 4K Block 为例，如果我们用 1bit 0/1 代表一个 Block 是否被分配，那么我们就可以使用磁盘大小的 32,768 分之一的内存表示当前磁盘 Block 的分配状态，对于一个 1T 的磁盘就需要 32MB 内存。如图所示：</p><p><img src=bitmap.png alt=bitmap.png></p><p>但是这种分配方式有种一个明显的弊端，就是当分配空间是需遍历整个位图的内存找到空闲的位置，时间复杂的是 $O(n)$ 最差的情况下需要遍历 32MB 内存的每一个 Bit 这种方式显然效率不高，所以 BlueStore 的位图 Allocator 使用了三层位图</p><p><img src=level-bitmap.png alt=level-bitmap.png></p><ul><li>L0 每个 bit 代表一个 Block，每 64byte (x86-64 cache line 大小) 作为一个 L0 slotset</li><li>L1 每个 bit 代表 L0 中的一个 slotset 是否完全分配，每 64byte 作为一个 L1 slotset</li><li>L2 每个 bit 代表 L1 中的一个 slotset 是否完全分配</li></ul><p>这种三层位图的分配方式，大大降低了分配一个 Block 最大只需要扫描内存数据，以 1T 的空间为例，位图大小为 32MB 那么 L2 的大小为 16byte 那么最多只要扫描 16+8+8 = 32byte 就能找到一个空闲的 Block，而且每个 slotset 都能完整的放入 CPU Cache Line 效率极高。</p></div><div class=post-footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//tomwei7.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main></body></html>