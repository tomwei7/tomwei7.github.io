<!doctype html><html lang=zh-cn><head><title>Docker 构建扁平化容器网络 // 围城</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.85.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="围城"><meta name=description content><link rel=stylesheet href=https://tomwei7.com/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-72226462-1','auto'),ga('send','pageview'))</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 构建扁平化容器网络"><meta name=twitter:description content="💡 网上有很多关于 k8s 偏平化网络建设的文章，大多针对于大规律的集群。但是现在也有很多人在 NAS 或者家庭服务器中也会使用 Docker 部署服务，本文主要介绍如何使"><meta property="og:title" content="Docker 构建扁平化容器网络"><meta property="og:description" content="💡 网上有很多关于 k8s 偏平化网络建设的文章，大多针对于大规律的集群。但是现在也有很多人在 NAS 或者家庭服务器中也会使用 Docker 部署服务，本文主要介绍如何使"><meta property="og:type" content="article"><meta property="og:url" content="https://tomwei7.com/2022/05/03/docker-macvlan-network/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-03T16:16:19+08:00"><meta property="article:modified_time" content="2022-05-03T16:16:19+08:00"></head><body><header class=app-header><a href=https://tomwei7.com><img class=app-header-avatar src=/avatar.png alt=围城></a>
<a href=https://tomwei7.com><h1>围城</h1></a><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>程序员-代码-吐槽</p></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Docker 构建扁平化容器网络</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 3, 2022</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>5 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://tomwei7.com/tags/docker/>docker</a>
<a class=tag href=https://tomwei7.com/tags/network/>network</a>
<a class=tag href=https://tomwei7.com/tags/macvlan/>macvlan</a></div></div></header><div class=post-content><blockquote><blockquote><p>💡 网上有很多关于 k8s 偏平化网络建设的文章，大多针对于大规律的集群。但是现在也有很多人在 NAS 或者家庭服务器中也会使用 Docker 部署服务，本文主要介绍如何使用 Docker 构建扁平化的网络，提供容器的跨主机互访能力。</p></blockquote></blockquote><p>随着 2013 年 Docker 的发布，容器技术开始走进了各大互联网公司。容器技术不仅仅服务于互联网公司的线上业务，同时也为开发人员搭建测试环境、三方依赖服务等提供了极大的便利。除了在企业中的应用，容器凭借着无依赖一键启动的优势也被越来越多的人用于在家庭 NAS 或者家庭服务器中部署服务，基本上属于必备软件。</p><p>家庭 NAS 或者家庭服务器中使用容器多使用 Docker 提供的 Bridge 网络，通过端口转发的方式将通过容器部署的服务暴露到局域网中，其主要实现方式如下:</p><p><img src=docker-bridge-network.png alt=docker-bridge-network.png></p><p>可以简单将 docker0 理解为一个 switch，container 通过 veth-pair 连接到这个 switch，host 通过 docker0 这个 interface 连接这这个 switch，container 发出的数据包经过 host 进行 NAT 后从主机的 eth0 端口流出。</p><blockquote><blockquote><p>💡 如果这里将 eth0 直接加到这个 bridge 中来实现也可以使用偏平化的网络，但是 Docker 没有提供这这样的功能，借用 cni 中的 bridge 插件实现 <a href=https://www.cni.dev/plugins/current/main/bridge/>https://www.cni.dev/plugins/current/main/bridge/</a></p></blockquote></blockquote><p>使用 Bridge 网络时由于经过了一层 NAT 转发，容器有自己的私有网段。在其他主机上访问容器服务只能通过端口转发的方式访问。那么有没有办法让容器在我们的局域网中用于“一席之地”（独立IP）呢？实际可行的方式有很多，这里主要介绍一下最简单的 macvlan 模式</p><h3 id=macvlan>macvlan</h3><p>macvlan 顾名思义就是一种基于 mac 地址的区分 vlan 的方式。普通的 802.1Q 的 vlan 通过在 frame（帧） 中添加特定 802.1Q tag 的方式实现在单个物理 interface 的基础上建立多个虚拟 interface，通过 tag 区分各个接口的流量。macvlan 的也可以在单个物理的 interface 上建立多个虚拟 interface 不过是通过 mac 地址区分流量</p><p><img src=macvlan.drawio.png alt=macvlan.drawio.png></p><p>macvlan 中的子 interface 直接的相互通信，可以设置三种模式</p><ul><li>Private: 子 interface 之间不允许相关通信，完全隔离</li><li>VEPA: 子 interface 之间的相互通信需要由外部交换机或路由处理</li><li>Bridge: 子 interface 之间可以相互通信，<strong>docker 中创建的 macvlan 网络只能使用 bridge 模式</strong></li></ul><p>详细可以参考 <a href=https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#macvlan>https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#macvlan</a></p><h3 id=docker-中使用-macvlan>Docker 中使用 macvlan</h3><p><strong>创建 macvlan 网络</strong></p><p>在 Docker 中创建 macvlan 十分简单，以我当前的网络环境为例在 enp3s0 interface 下创建 macvlan 网络</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> enp3s0<span style=color:#f92672>:</span> &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#ae81ff>1500</span> qdisc fq_codel state UP <span style=color:#66d9ef>group</span> default qlen <span style=color:#ae81ff>1000</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    link<span style=color:#f92672>/</span>ether a8<span style=color:#f92672>:</span>a1<span style=color:#f92672>:</span><span style=color:#ae81ff>59</span><span style=color:#f92672>:</span><span style=color:#ae81ff>24</span><span style=color:#f92672>:</span>d0<span style=color:#f92672>:</span><span style=color:#ae81ff>61</span> brd ff<span style=color:#f92672>:</span>ff<span style=color:#f92672>:</span>ff<span style=color:#f92672>:</span>ff<span style=color:#f92672>:</span>ff<span style=color:#f92672>:</span>ff<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    inet <span style=color:#ae81ff>192.168.88.9</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> metric <span style=color:#ae81ff>1024</span> brd <span style=color:#ae81ff>192.168.88.255</span> scope global dynamic enp3s0<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>       valid_lft <span style=color:#ae81ff>551</span>sec preferred_lft <span style=color:#ae81ff>551</span>sec<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    inet6 fe80<span style=color:#f92672>::</span>aaa1<span style=color:#f92672>:</span><span style=color:#ae81ff>59ff</span><span style=color:#f92672>:</span>fe24<span style=color:#f92672>:</span>d061<span style=color:#f92672>/</span><span style=color:#ae81ff>64</span> scope link<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>       valid_lft forever preferred_lft forever<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>enp3s0 所在的网段为 192.168.88.0/24</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf>docker network create <span style=color:#960050;background-color:#1e0010>\
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#f92672>-</span>d macvlan <span style=color:#960050;background-color:#1e0010>\
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#f92672>--</span>subnet<span style=color:#f92672>=</span><span style=color:#ae81ff>192.168.88.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>24</span> <span style=color:#960050;background-color:#1e0010>\
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#f92672>--</span>ip<span style=color:#f92672>-</span>range<span style=color:#f92672>=</span><span style=color:#ae81ff>192.168.88.192</span><span style=color:#f92672>/</span><span style=color:#ae81ff>27</span> <span style=color:#960050;background-color:#1e0010>\
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#f92672>--</span>gateway <span style=color:#ae81ff>192.168.88.1</span> <span style=color:#960050;background-color:#1e0010>\
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#f92672>-</span>o parent<span style=color:#f92672>=</span>enp3s0 <span style=color:#960050;background-color:#1e0010>\
</span><span style=color:#960050;background-color:#1e0010></span>	<span style=color:#f92672>--</span>aux<span style=color:#f92672>-</span>address <span style=color:#e6db74>&#39;host=192.168.88.192&#39;</span> <span style=color:#960050;background-color:#1e0010>\
</span><span style=color:#960050;background-color:#1e0010></span>	macvlan1<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p><strong>subnet</strong></p><p>子网网段，这里与接口网段一致即可</p><p><strong>ip-range</strong></p><p>容器可用的 IP 范围 ，由于容器并不会使用 dhcp 获取 IP 地址，所以指定的 ip-range 应该与路由器中的 dhcp IP 范围错开，例如我这里的 dhcp 服务器只会分配 192.168.88.64-192.168.88.127 共 64 个 IP，这里让容器使用 192.168.88.192-192.168.88.192.223</p><p><strong>gateway</strong></p><p>网关地址，与接口网段一致即可</p><p><strong>aux-address</strong></p><p>辅助地址，相当于保留地址，分配IP地址时会避开相关 IP</p><p>使用 docker network ls 即可查看已经创建的网络</p><pre><code>docker network ls
NETWORK ID     NAME       DRIVER    SCOPE
fbe90109e5f2   bridge     bridge    local
9186dabfe83e   host       host      local
a373956bfe01   macvlan1   macvlan   local
47312fa573ea   none       null      local
</code></pre><p><strong>使用 macvlan 创建容器</strong></p><p>创建好 macvlan 网络后即可使用 macvlan 网络创建容器，使用 <code>—-network</code> 指定网络</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker run --network macvlan1 -it --rm alpine sh
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>/ <span style=color:#75715e># ip addr</span>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style=color:#ae81ff>65536</span> qdisc noqueue state UNKNOWN qlen <span style=color:#ae81ff>1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
23: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noqueue state UP
    link/ether 02:42:c0:a8:58:c1 brd ff:ff:ff:ff:ff:ff
    inet 192.168.88.193/24 brd 192.168.88.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre></div><p>这时容器已经获取了一个独立的局域网 IP，相当于局域网内的一台独立机器。可以在局域网内的其他机器中直接访问</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>λ ~ ping 192.168.88.193
PING 192.168.88.193 <span style=color:#f92672>(</span>192.168.88.193<span style=color:#f92672>)</span>: <span style=color:#ae81ff>56</span> data bytes
<span style=color:#ae81ff>64</span> bytes from 192.168.88.193: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>1.739 ms
<span style=color:#ae81ff>64</span> bytes from 192.168.88.193: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.743 ms
^C
--- 192.168.88.193 ping statistics ---
<span style=color:#ae81ff>2</span> packets transmitted, <span style=color:#ae81ff>2</span> packets received, 0.0% packet loss
round-trip min/avg/max/stddev <span style=color:#f92672>=</span> 0.743/1.241/1.739/0.498 ms
</code></pre></div><p><strong>但是这时并没有办法在当前宿主机（即容器所在的机器）上访问容器</strong>，这是因为宿主机上发出的数据包会直接经过物理接口 enp3s0 流出而不会进行 macvlan 内部的 bridge，到达外部网络设备后除非外部的交换机或者路由器支持 <a href=https://en.wikipedia.org/wiki/Hairpinning>hairpin mode</a> 否则无法进行访问。所以我们需要给宿主机添加一个 macvlan 的 interface 用于访问容器</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 创建一个 bridge 模式的 macvlan interface docker-link</span>
ip link add docker-link link enp3s0 type macvlan mode bridge
<span style=color:#75715e># 设置 docker-link 地址，使用 aux-address 中保留的 IP 地址</span>
ip addr add 192.168.88.192/27 brd + dev docker-link
<span style=color:#75715e># 启用 docker-link 接口</span>
ip link set docker-link up
<span style=color:#75715e># 添加路由 将 192.168.88.192/27 网段流量指向 docker-link 接口</span>
ip route add 192.168.88.192/27 dev docker-link
</code></pre></div><p>此时我们就可以在宿主机中顺利访问容器</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>tomwei7@my-lab-a300 λ ~ ping 192.168.88.193
PING 192.168.88.193 <span style=color:#f92672>(</span>192.168.88.193<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
<span style=color:#ae81ff>64</span> bytes from 192.168.88.193: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.038 ms
<span style=color:#ae81ff>64</span> bytes from 192.168.88.193: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.070 ms
^C
--- 192.168.88.193 ping statistics ---
<span style=color:#ae81ff>2</span> packets transmitted, <span style=color:#ae81ff>2</span> received, 0% packet loss, time 1005ms
rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.038/0.054/0.070/0.016 ms
</code></pre></div><h3 id=macvlan-配合-8021q-vlan>macvlan 配合 802.1q VLAN</h3><p>macvlan 的父接口不一定要是物理接口，也可以是 vlan 接口，这里 Docker 做了一点点语法糖如果父接口中包含 . 则会创建对应的 vlan 接口，例如创建如下 macvlan 网络，</p><ul><li>vlan id 200</li><li>网段 192.168.200.0/24</li><li>网关 192.168.200.1</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker network create <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	-d macvlan <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	--subnet<span style=color:#f92672>=</span>192.168.200.0/24 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	--ip-range<span style=color:#f92672>=</span>192.168.200.0/24 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	--gateway 192.168.200.1 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	-o parent<span style=color:#f92672>=</span>enp3s0.200 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	macvlan2
</code></pre></div><p>docker 会自动创建对应的 vlan interface</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ip -details link show

26: enp3s0.200@enp3s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noqueue state UP mode DEFAULT group default
    link/ether a8:a1:59:24:d0:61 brd ff:ff:ff:ff:ff:ff promiscuity <span style=color:#ae81ff>0</span> minmtu <span style=color:#ae81ff>0</span> maxmtu <span style=color:#ae81ff>65535</span>
    vlan protocol 802.1Q id <span style=color:#ae81ff>200</span> &lt;REORDER_HDR&gt; addrgenmode eui64 numtxqueues <span style=color:#ae81ff>1</span> numrxqueues <span style=color:#ae81ff>1</span> gso_max_size <span style=color:#ae81ff>64000</span> gso_max_segs <span style=color:#ae81ff>64</span>
</code></pre></div><p>使用 vlan 还需要在路由器中进行对应的配置以及防火墙规则，</p><p>以当前网络使用的 RouterOS 为例需要添加 vlan interface 以及为对应 interface 设置 IP</p><pre><code># main-bridge 为当前机器连接的接口所在 bridge 也可以直接设置在端口上
/interface/vlan/add interface=main-bridge vlan-id=200 name=vlan-200-docker-demo
/ip/address/add address=192.168.200.1/24 interface=vlan-200-docker-demo
</code></pre><p>可能大部分人的路由器系统是 openwrt，openwrt 环境下则可以直接通过 UI 操作，在 Network / interface 下添加新的 interface。protocol 选择 static address，device 选择 custom device 名称格式为 interface.vlanid 比如这里使用 br-lan 接口 vlan 为 200 则 device 名称为 br-lan.200</p><p><img src=openwrt-vlan-01.png alt=openwrt-vlan-01.png></p><p>随后为 interface 设置 IP 即可</p><p><img src=openwrt-vlan-02.png alt=openwrt-vlan-02.png></p><blockquote><blockquote><p>💡 如果主机不是直接连接到路由器还存在交换机等还需要进行对应等 vlan 设置这里不做赘述</p></blockquote></blockquote><h3 id=其他>其他</h3><p>上文主要是以 docker 为例，其他例如 podman 也可以类似的功能。扁平化的容器网络可以让我们的容器在局域网中拥有“姓名” (IP)，相较于 bridge 网络不需要考虑端口够不够用、应该暴露那些端口等等问题，同时也能让宿主机的 iptables 清爽很多。</p></div><div class=post-footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//tomwei7.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main></body></html>